<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PSYOP - Electronic Music</title>
  <link rel="stylesheet" href="/css/style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;500;600;700&display=swap"
    rel="stylesheet">
  <!-- Three.js for WebGL physics -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>

<body>

  <!-- Dynamic background system -->
  <div class="dynamic-background" id="dynamic-background">
    <!-- Transition overlay for smooth image changes -->
    <div class="transition-overlay" id="transition-overlay"></div>
    <!-- White images for vertical screens -->
    <img src="/assets/white/promo_1.jpg" class="background-image" data-index="0" alt="Background 1">
    <img src="/assets/white/promo_2.jpg" class="background-image" data-index="1" alt="Background 2">
    <img src="/assets/white/promo_3.jpg" class="background-image" data-index="2" alt="Background 3">
    <img src="/assets/white/promo_4.jpg" class="background-image" data-index="3" alt="Background 4">
    <img src="/assets/white/promo_5.jpg" class="background-image" data-index="4" alt="Background 5">
    <img src="/assets/white/promo_6.jpg" class="background-image" data-index="5" alt="Background 6">
    <img src="/assets/white/promo_7.jpg" class="background-image" data-index="6" alt="Background 7">
    <img src="/assets/white/promo_8.jpg" class="background-image" data-index="7" alt="Background 8">
    <img src="/assets/white/promo_9.jpg" class="background-image" data-index="8" alt="Background 9">
    <img src="/assets/white/promo_10.jpg" class="background-image" data-index="9" alt="Background 10">
    <img src="/assets/white/promo_11.jpg" class="background-image" data-index="10" alt="Background 11">
    <img src="/assets/white/promo_12.jpg" class="background-image" data-index="11" alt="Background 12">

    <!-- Red images for wide screens -->
    <img src="/assets/red_white/promo_1.jpg" class="background-image red-image" data-index="0" alt="Red Background 1">
    <img src="/assets/red_white/promo_2.jpg" class="background-image red-image" data-index="1" alt="Red Background 2">
    <img src="/assets/red_white/promo_3.jpg" class="background-image red-image" data-index="2" alt="Red Background 3">
    <img src="/assets/red_white/promo_4.jpg" class="background-image red-image" data-index="3" alt="Red Background 4">
    <img src="/assets/red_white/promo_5.jpg" class="background-image red-image" data-index="4" alt="Red Background 5">
    <img src="/assets/red_white/promo_6.jpg" class="background-image red-image" data-index="5" alt="Red Background 6">
    <img src="/assets/red_white/promo_7.jpg" class="background-image red-image" data-index="6" alt="Red Background 7">
    <img src="/assets/red_white/promo_8.jpg" class="background-image red-image" data-index="7" alt="Red Background 8">
    <img src="/assets/red_white/promo_9.jpg" class="background-image red-image" data-index="8" alt="Red Background 9">
    <img src="/assets/red_white/promo_10.jpg" class="background-image red-image" data-index="9" alt="Red Background 10">
    <img src="/assets/red_white/promo_11.jpg" class="background-image red-image" data-index="10"
      alt="Red Background 11">
    <img src="/assets/red_white/promo_12.jpg" class="background-image red-image" data-index="11"
      alt="Red Background 12">
  </div>

  <!-- The menu, placed on top of the animated background -->
  <header id="main-menu">
    <nav>
      <ul>
        <li><a href="#home" class="menu-link active">Home</a></li>
        <li><a href="#music" class="menu-link">Music</a></li>
        <li><a href="#links" class="menu-link">Links</a></li>
        <li><a href="#shows" class="menu-link">Upcoming Shows</a></li>
      </ul>
    </nav>
  </header>

  <!-- Main content for scrolling -->
  <main>
    <section id="home" class="page">
      <div class="page-content">
        <!-- Stacked Polaroid Gallery -->
        <div class="polaroid-stack">
          <!-- Navigation Arrows -->
          <button class="nav-arrow nav-left">‹</button>
          <button class="nav-arrow nav-right">›</button>

          <!-- Polaroid Stack Container -->
          <div class="polaroid-stack-container">
            <!-- psyop 01 Moonlight Paradox (Only Card) -->
            <div class="polaroid-frame stack-item active" data-index="0">
              <img src="/assets/white/promo_5.jpg" alt="PSYOP 01 Moonlight Paradox"
                style="width: 100%; height: auto; border: 2px solid red;" data-fallback="/assets/white/promo_1.jpg">
              <div class="polaroid-caption">psyop 01 Moonlight Paradox<br>April 2025</div>
            </div>
          </div>
        </div>

        <div class="scroll-indicator">
          <div class="scroll-text">Scroll Down</div>
          <div class="scroll-arrow" onclick="scrollToNextSection()">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M7 10L12 15L17 10" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                stroke-linejoin="round" />
            </svg>
          </div>
        </div>
      </div>
    </section>

    <section id="music" class="page">
      <div class="page-content">
        <h2>Music</h2>
        <div class="music-tracks">
          <!-- psyop 02 Great in Vain (Now First) -->
          <div class="track-item">
            <div class="track-artwork">
              <img src="/assets/white/promo_1.jpg" alt="psyop 02 Great in Vain" loading="lazy" decoding="async"
                data-fallback="/assets/white/promo_2.jpg">
            </div>
            <div class="track-info">
              <h3>psyop 02 Great in Vain</h3>
              <p class="track-status">August 2025</p>
              <a href="#" class="track-link disabled">
                Coming Soon
              </a>
            </div>
          </div>

          <!-- psyop 01 Moonlight Paradox (Now Second) -->
          <div class="track-item">
            <div class="track-artwork">
              <img src="/assets/white/promo_5.jpg" alt="psyop 01 Moonlight Paradox" loading="lazy" decoding="async"
                data-fallback="/assets/white/promo_6.jpg">
            </div>
            <div class="track-info">
              <h3>psyop 01 Moonlight Paradox</h3>
              <p class="track-status">April 2025</p>
              <a href="https://distrokid.com/hyperfollow/psyop21/moonlight-paradox" target="_blank"
                rel="noopener noreferrer" class="track-link">
                Listen Now
              </a>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section id="links" class="page">
      <div class="page-content">
      </div>
    </section>

    <section id="shows" class="page">
      <div class="page-content">
      </div>
    </section>
  </main>

  <script>
    // Dynamic background system
    class DynamicBackground {
      constructor() {
        this.backgroundContainer = document.getElementById('dynamic-background');
        this.backgroundImages = document.querySelectorAll('.background-image');
        this.currentImageIndex = 0;
        this.isWideScreen = window.innerWidth > window.innerHeight;
        this.recentImages = []; // Track recently used images
        this.minRepeatDistance = 6; // Minimum images before repetition
        this.usedCount = 0; // Simple counter instead of array length
        this.scrollTimeout = null; // For scroll idle detection
        this.isTransitioning = false; // Track transition state
        this.init();
      }

      init() {
        // Check if required elements exist
        if (!this.backgroundContainer) {
          console.error('Dynamic background container not found!');
          return;
        }

        // Show first image
        this.showImage(0);

        // Log available images for debugging
        const whiteImages = document.querySelectorAll('.background-image:not(.red-image)');
        const redImages = document.querySelectorAll('.red-image');
        console.log(`Available images - White: ${whiteImages.length}, Red: ${redImages.length}`);

        // Add event listeners
        window.addEventListener('scroll', this.handleScroll.bind(this));
        window.addEventListener('resize', this.handleResize.bind(this));

        // Initialize manual menu highlighting
        this.initManualMenuHighlighting();

        // Initialize background state (start with scrolling state)
        this.backgroundContainer.classList.add('scrolling');
      }

      handleScroll() {
        const scrollPosition = window.scrollY;
        const windowHeight = window.innerHeight;
        const documentHeight = document.body.scrollHeight;

        // Calculate scroll progress as a percentage (0 to 1)
        const scrollProgress = scrollPosition / (documentHeight - windowHeight);

        // Update background image based on current page, not scroll progress
        this.updateBackgroundImageByPage(scrollPosition, windowHeight);

        // Update menu highlighting based on scroll position
        this.updateMenuHighlighting(scrollPosition);

        // Handle scroll idle detection for background blur effect
        this.handleScrollIdle();

        // REMOVED: animatePolaroid(scrollPosition) - polaroids should not animate on scroll
      }

      updateBackgroundImage(sectionIndex) {
        // Don't change background if manual navigation is active
        if (window.isManualNavigation) {
          return;
        }

        // Determine which image set to use based on screen orientation
        const images = this.isWideScreen ?
          document.querySelectorAll('.red-image') :
          document.querySelectorAll('.background-image:not(.red-image)');

        if (images.length === 0) {
          console.warn('No images found for current screen orientation');
          return;
        }

        // Calculate image index based on section
        const imageIndex = sectionIndex % images.length;

        // Only change background if it's actually different and we're not in the middle of a transition
        if (imageIndex !== this.currentImageIndex && !this.isTransitioning) {
          console.log(`Page ${sectionIndex + 1} in view, changing to background ${imageIndex + 1}`);
          this.showImage(imageIndex);
          this.currentImageIndex = imageIndex;
        }
      }

      updateBackgroundImageByPage(scrollPosition, windowHeight) {
        // Don't change background if manual navigation is active
        if (window.isManualNavigation || this.isManualNavigation) {
          return;
        }

        // Get all page sections
        const pages = document.querySelectorAll('.page');
        if (pages.length === 0) return;

        // Find which page is currently most visible in the viewport
        let mostVisiblePage = 0;
        let maxVisibility = 0;

        pages.forEach((page, index) => {
          const rect = page.getBoundingClientRect();
          const pageHeight = rect.height;

          // Calculate how much of the page is visible
          const visibleTop = Math.max(0, Math.min(rect.height, windowHeight - rect.top));
          const visibleBottom = Math.max(0, Math.min(rect.height, rect.bottom));
          const visibleHeight = Math.min(visibleTop, visibleBottom);

          // Calculate visibility percentage
          const visibility = visibleHeight / pageHeight;

          if (visibility > maxVisibility) {
            maxVisibility = visibility;
            mostVisiblePage = index;
          }
        });

        // Only change background if a page is more than 70% visible
        if (maxVisibility > 0.7) {
          // Always select a fresh, different image instead of mapping page to image
          this.selectFreshBackgroundImage(mostVisiblePage);
        }
      }

      selectFreshBackgroundImage(pageIndex) {
        // Don't change background if manual navigation is active
        if (window.isManualNavigation || this.isManualNavigation) {
          return;
        }

        // Get the appropriate image set
        const images = this.isWideScreen ?
          document.querySelectorAll('.red-image') :
          document.querySelectorAll('.background-image:not(.red-image)');

        if (images.length === 0) {
          console.warn('No images found for current screen orientation');
          return;
        }

        // Find a fresh image that's different from the current one
        let newImageIndex = this.findFreshImageIndex(images.length);

        // Only change if we found a different image
        if (newImageIndex !== this.currentImageIndex) {
          console.log(`Page ${pageIndex + 1} in view, selecting fresh background ${newImageIndex + 1}`);
          this.showImage(newImageIndex);
        }
      }

      findFreshImageIndex(totalImages) {
        if (totalImages <= 1) return 0;

        // Try to find an image that hasn't been used recently
        let attempts = 0;
        const maxAttempts = totalImages * 2; // Allow multiple passes through the array

        while (attempts < maxAttempts) {
          // Generate a random index to ensure variety
          const randomIndex = Math.floor(Math.random() * totalImages);

          // Check if this image hasn't been used recently
          if (!this.recentImages.includes(randomIndex)) {
            // Add to recent images and remove oldest if we exceed the limit
            this.recentImages.push(randomIndex);
            if (this.recentImages.length > this.minRepeatDistance) {
              this.recentImages.shift();
            }
            return randomIndex;
          }

          attempts++;
        }

        // If all images have been used recently, reset tracking and pick random
        this.recentImages = [];
        const freshIndex = Math.floor(Math.random() * totalImages);
        this.recentImages.push(freshIndex);
        return freshIndex;
      }

      showImage(index) {
        // Don't start a new transition if one is already in progress
        if (this.isTransitioning) {
          console.log('Transition already in progress, skipping...');
          return;
        }

        // Get the appropriate image set
        const images = this.isWideScreen ?
          document.querySelectorAll('.red-image') :
          document.querySelectorAll('.background-image:not(.red-image)');

        if (images.length === 0) {
          console.warn(`No images found for ${this.isWideScreen ? 'wide' : 'vertical'} screen orientation`);
          return;
        }

        // Ensure index is within bounds
        const clampedIndex = Math.min(Math.max(index, 0), images.length - 1);

        // Set transition state
        this.isTransitioning = true;

        // Show transition overlay
        const transitionOverlay = document.getElementById('transition-overlay');
        if (transitionOverlay) {
          transitionOverlay.classList.add('active');
        } else {
          console.warn('Transition overlay element not found');
        }

        // Hide all images first
        this.backgroundImages.forEach(img => img.classList.remove('active'));

        // Show the target image after a short delay
        setTimeout(() => {
          if (images[clampedIndex]) {
            images[clampedIndex].classList.add('active');
            this.usedCount++;
          } else {
            console.error(`Image at index ${clampedIndex} not found`);
          }

          // Hide transition overlay after image is visible
          setTimeout(() => {
            if (transitionOverlay) {
              transitionOverlay.classList.remove('active');
            }
            // Reset transition state
            this.isTransitioning = false;
          }, 600);

          // Update current index
          this.currentImageIndex = clampedIndex;
        }, 300);
      }

      findNonRepeatingImage(baseIndex, totalImages) {
        // Haskell-style non-repetition algorithm
        // Track recently used images to avoid repetition
        let candidateIndex = baseIndex;

        // Try to find an image that hasn't been used recently
        for (let attempts = 0; attempts < totalImages; attempts++) {
          // Ensure index is within bounds
          candidateIndex = (baseIndex + attempts) % totalImages;

          // Check if this image hasn't been used in the last minRepeatDistance images
          if (!this.recentImages.includes(candidateIndex)) {
            // Add to recent images and remove oldest if we exceed the limit
            this.recentImages.push(candidateIndex);
            if (this.recentImages.length > this.minRepeatDistance) {
              this.recentImages.shift();
            }
            return candidateIndex;
          }
        }

        // If all images have been used recently, reset the tracking and use base index
        this.recentImages = [];
        this.recentImages.push(baseIndex);
        return baseIndex;
      }

      handleResize() {
        const wasWideScreen = this.isWideScreen;
        this.isWideScreen = window.innerWidth > window.innerHeight;

        // If orientation changed, update image display
        if (wasWideScreen !== this.isWideScreen) {
          console.log(`Screen orientation changed to ${this.isWideScreen ? 'wide' : 'vertical'}`);
          this.showImage(this.currentImageIndex);
        }
      }

      handleScrollIdle() {
        // Clear existing timeout
        if (this.scrollTimeout) {
          clearTimeout(this.scrollTimeout);
        }

        // Remove idle class (show scrolling state)
        this.backgroundContainer.classList.remove('idle');
        this.backgroundContainer.classList.add('scrolling');

        // Set timeout to add idle class after scrolling stops
        this.scrollTimeout = setTimeout(() => {
          this.backgroundContainer.classList.remove('scrolling');
          this.backgroundContainer.classList.add('idle');
        }, 1000); // 1 second delay before applying blur
      }

      updateMenuHighlighting(scrollPosition) {
        const sections = ['home', 'music', 'links', 'shows'];
        const windowHeight = window.innerHeight;
        let currentSection = 'home';

        sections.forEach(sectionId => {
          const section = document.getElementById(sectionId);
          if (section) {
            const rect = section.getBoundingClientRect();
            if (rect.top <= windowHeight * 0.5 && rect.bottom >= windowHeight * 0.5) {
              currentSection = sectionId;

              // Update active page class for scroll indicator logic
              document.querySelectorAll('.page').forEach(page => page.classList.remove('active'));
              section.classList.add('active');

              // Show/hide scroll indicator based on current section
              const scrollIndicator = document.querySelector('.scroll-indicator');
              if (scrollIndicator) {
                if (sectionId === 'home') {
                  scrollIndicator.style.display = 'block';
                  scrollIndicator.classList.remove('hidden');
                } else {
                  scrollIndicator.style.display = 'none';
                  scrollIndicator.classList.add('hidden');
                }
              }
            }
          }
        });

        // Update menu highlighting
        const menuLinks = document.querySelectorAll('.menu-link');
        menuLinks.forEach(link => {
          link.classList.remove('active');
          if (link.getAttribute('href') === `#${currentSection}`) {
            link.classList.add('active');
          }
        });
      }

      initManualMenuHighlighting() {
        const menuLinks = document.querySelectorAll('.menu-link');

        if (menuLinks.length === 0) {
          console.warn('No menu links found');
          return;
        }

        // Add click event listeners to each menu link
        menuLinks.forEach(link => {
          link.addEventListener('click', (e) => {
            e.preventDefault(); // Prevent default anchor behavior

            // Remove active class from all links
            menuLinks.forEach(l => l.classList.remove('active'));

            // Add active class to clicked link
            link.classList.add('active');

            // Smooth scroll to section
            const targetId = link.getAttribute('href').substring(1);
            const targetSection = document.getElementById(targetId);
            if (targetSection) {
              targetSection.scrollIntoView({ behavior: 'smooth' });
            } else {
              console.warn(`Target section ${targetId} not found`);
            }
          });
        });

        // Set home as initially active
        const homeLink = document.querySelector('a[href="#home"]');
        if (homeLink) {
          homeLink.classList.add('active');
        } else {
          console.warn('Home link not found');
        }
      }
    }

    // Initialize the dynamic background system
    const dynamicBackground = new DynamicBackground();

    // Polaroid navigation system
    let currentPolaroidIndex = 0;
    const totalPolaroids = 1; // Changed from 3 to 1
    let isManualNavigation = false; // Flag to prevent background interference

    // Make the flag globally accessible for the background system
    window.isManualNavigation = false;

    function showPolaroid(index) {
      // Validate index
      if (index < 0 || index >= totalPolaroids) {
        console.error(`Invalid polaroid index: ${index}`);
        return;
      }

      // Set manual navigation flag to prevent background interference
      isManualNavigation = true;
      window.isManualNavigation = true;

      // Hide all polaroids
      const stackItems = document.querySelectorAll('.stack-item');
      if (stackItems.length === 0) {
        console.warn('No polaroid stack items found');
        return;
      }

      stackItems.forEach(item => {
        item.classList.remove('active');
        // Reset any transform styles that might have been applied
        item.style.transform = '';
      });

      // Show the selected polaroid
      const targetPolaroid = document.querySelector(`[data-index="${index}"]`);
      if (targetPolaroid) {
        targetPolaroid.classList.add('active');
        currentPolaroidIndex = index;

        // Update button visibility based on current position
        updateNavigationButtons();
      } else {
        console.error(`Polaroid with data-index="${index}" not found`);
      }

      // Reset manual navigation flag after a longer delay to ensure background doesn't interfere
      setTimeout(() => {
        isManualNavigation = false;
        window.isManualNavigation = false;
      }, 1000); // Increased delay to prevent background interference
    }

    function nextPolaroid() {
      // No next polaroid since we only have one
      console.log('Only one polaroid card - no next available');
    }

    function previousPolaroid() {
      // No previous polaroid since we only have one
      console.log('Only one polaroid card - no previous available');
    }

    function updateNavigationButtons() {
      const leftButton = document.querySelector('.nav-left');
      const rightButton = document.querySelector('.nav-right');

      if (!leftButton || !rightButton) {
        console.warn('Navigation buttons not found');
        return;
      }

      // Since we only have one card, hide both navigation buttons
      leftButton.style.display = 'none';
      leftButton.classList.remove('visible');
      rightButton.style.display = 'none';
      rightButton.classList.remove('visible');
    }

    // Initialize with first polaroid visible
    document.addEventListener('DOMContentLoaded', function () {
      showPolaroid(0);

      // Set home page as initially active
      document.getElementById('home').classList.add('active');

      // Ensure scroll indicator is visible on home page initially
      const scrollIndicator = document.querySelector('.scroll-indicator');
      if (scrollIndicator) {
        scrollIndicator.style.display = 'block';
        scrollIndicator.classList.remove('hidden');
      }

      // Add click event to scroll indicator
      if (scrollIndicator) {
        scrollIndicator.addEventListener('click', scrollToNextSection);
      }

      // Initialize image error handling
      initializeImageErrorHandling();

      // Initialize polaroid hover functionality
      initializePolaroidHover();
    });

    // Scroll to next section function
    function scrollToNextSection() {
      const currentSection = document.querySelector('.page.active') || document.getElementById('home');
      const nextSection = currentSection.nextElementSibling;

      if (nextSection && nextSection.classList.contains('page')) {
        // Smooth scroll to next section
        nextSection.scrollIntoView({ behavior: 'smooth' });

        // Hide the scroll indicator after use (it will be shown/hidden by updateMenuHighlighting)
        const scrollIndicator = document.querySelector('.scroll-indicator');
        if (scrollIndicator) {
          scrollIndicator.classList.add('hidden');
        }
      }
    }

    // Image error handling and fallback system
    function initializeImageErrorHandling() {
      const images = document.querySelectorAll('img[data-fallback]');

      images.forEach(img => {
        // Set initial opacity for music track images
        if (img.closest('.track-artwork')) {
          img.style.opacity = '0';
          img.style.transition = 'opacity 0.5s ease-in-out';
        }

        // Handle successful image load
        img.addEventListener('load', function () {
          if (this.closest('.track-artwork')) {
            this.style.opacity = '1';
          }
          console.log('Image loaded successfully:', this.src);
        });

        // Handle image load errors
        img.addEventListener('error', function () {
          const fallbackSrc = this.getAttribute('data-fallback');
          if (fallbackSrc && this.src !== fallbackSrc) {
            console.warn('Image failed to load, using fallback:', this.src, '->', fallbackSrc);
            this.src = fallbackSrc;
          } else {
            console.error('Image failed to load and no fallback available:', this.src);
            // Show a placeholder or error state
            this.style.opacity = '0.5';
            this.style.filter = 'grayscale(100%)';
          }
        });
      });
    }

    // Initialize polaroid hover functionality
    function initializePolaroidHover() {
      const polaroidStack = document.querySelector('.polaroid-stack');
      const leftButton = document.querySelector('.nav-left');
      const rightButton = document.querySelector('.nav-right');

      if (!polaroidStack) {
        console.warn('Polaroid stack not found');
        return;
      }

      if (!leftButton || !rightButton) {
        console.warn('Navigation buttons not found for hover functionality');
        return;
      }

      // Show buttons on hover over the extended zone
      polaroidStack.addEventListener('mouseenter', function () {
        updateNavigationButtons();
      });

      // Hide buttons when leaving the extended zone
      polaroidStack.addEventListener('mouseleave', function (e) {
        // Check if we're moving to a button (don't hide if hovering over button)
        const relatedTarget = e.relatedTarget;
        if (relatedTarget && (relatedTarget.classList.contains('nav-arrow') ||
          relatedTarget.closest('.nav-arrow'))) {
          return; // Don't hide if moving to a button
        }

        // Small delay to allow moving to buttons
        setTimeout(() => {
          // Check if we're still hovering over the extended zone
          const isOverStack = polaroidStack.matches(':hover');
          const isOverButton = document.querySelector('.nav-arrow:hover');

          if (!isOverStack && !isOverButton) {
            if (leftButton) {
              leftButton.style.display = 'none';
              leftButton.classList.remove('visible');
            }
            if (rightButton) {
              rightButton.style.display = 'none';
              rightButton.classList.remove('visible');
            }
          }
        }, 100);
      });

      // Prevent button clicks from triggering background changes
      leftButton.addEventListener('click', function (e) {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        previousPolaroid();
        return false;
      });

      rightButton.addEventListener('click', function (e) {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        nextPolaroid();
        return false;
      });

      // Keep buttons visible when hovering over them
      leftButton.addEventListener('mouseenter', function () {
        this.style.display = 'block';
        this.classList.add('visible');
      });

      rightButton.addEventListener('mouseenter', function () {
        this.style.display = 'block';
        this.classList.add('visible');
      });

      // Prevent buttons from triggering any scroll or background events
      leftButton.addEventListener('mousedown', function (e) {
        e.preventDefault();
        e.stopPropagation();
      });

      rightButton.addEventListener('mousedown', function (e) {
        e.preventDefault();
        e.stopPropagation();
      });
    }

  </script>

</body>

</html>