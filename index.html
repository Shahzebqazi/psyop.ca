<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scroll-Based WebGL UI</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* General styling and font setup */
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            color: #fff;
            background-color: #000;
        }

        /* WebGL canvas always on top and full screen */
        #background-shader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
        }

        /* Main content container */
        main {
            position: relative;
            z-index: 1;
            padding-top: 80px; /* Space for the header menu */
        }

        /* Page sections for scrolling */
        .page {
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 0 20px;
            box-sizing: border-box;
        }

        /* Menu styling */
        #main-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 10;
            background: rgba(0, 0, 0, 0.5); /* Semi-transparent background */
            backdrop-filter: blur(5px);
            padding: 15px 0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            animation: fadeInDown 0.5s ease-out forwards;
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        #main-menu ul {
            list-style: none;
            display: flex;
            justify-content: center;
            padding: 0;
            margin: 0;
        }

        #main-menu li {
            margin: 0 20px;
        }

        #main-menu a {
            text-decoration: none;
            color: #aaa;
            font-size: 18px;
            font-weight: 500;
            transition: color 0.3s ease-in-out;
        }

        #main-menu a:hover {
            color: #fff;
        }

        #main-menu a.active {
            color: #fff;
            border-bottom: 2px solid #fff;
        }

        /* Headings and text styling */
        h2 {
            font-size: 3em;
            text-transform: uppercase;
        }
    </style>
</head>
<body>

<!-- The WebGL canvas that will be our animated background -->
<canvas id="background-shader"></canvas>

<!-- The menu, placed on top of the canvas -->
<header id="main-menu">
  <nav>
    <ul>
      <li><a href="#home" class="menu-link active">Home</a></li>
      <li><a href="#music" class="menu-link">Music</a></li>
      <li><a href="#shows" class="menu-link">Upcoming Shows</a></li>
      <li><a href="#links" class="menu-link">Links</a></li>
    </ul>
  </nav>
</header>

<!-- Main content for scrolling -->
<main>
  <section id="home" class="page">
    <h2>README: Introduction</h2>
    <p>This project is a modern, responsive web page GUI with a dynamic background powered by WebGL shaders that smoothly transitions between different animated wallpapers as the user scrolls.</p>
    
    <h3>Features</h3>
    <ul>
        <li><strong>Dynamic Background</strong>: A fullscreen WebGL canvas with an animated, customizable shader.</li>
        <li><strong>Scroll-Based Transitions</strong>: The background "wallpaper" changes smoothly as the user scrolls, driven by the scroll position.</li>
        <li><strong>Responsive Menu</strong>: A sleek, sticky header with an active state that highlights the current page.</li>
        <li><strong>Separation of Concerns</strong>: The code is separated into HTML for structure, CSS for styling, and JavaScript for behavior, making it easy to maintain and expand.</li>
    </ul>
    
    <h3>Core Technologies</h3>
    <ul>
        <li><strong>HTML5</strong>: Provides the page structure and semantic content.</li>
        <li><strong>CSS3</strong>: Handles all styling, animations, and responsive design.</li>
        <li><strong>JavaScript</strong>: Manages user interactions (scroll events) and orchestrates the connection between the UI and the shader.</li>
        <li><strong>WebGL & Three.js</strong>: Provides a powerful, high-performance rendering context for the animated background.</li>
        <li><strong>GLSL (OpenGL Shading Language)</strong>: The low-level language used to write the shader program that creates the dynamic background.</li>
    </ul>
    
    <h3>Future Development</h3>
    <p>This codebase is designed to be easily integrated with a backend server and database. Potential future steps include:</p>
    <ul>
        <li><strong>Backend Integration</strong>: Implementing an API to serve dynamic content or user-specific data.</li>
        <li><strong>User Authentication</strong>: Adding a login system and user accounts.</li>
        <li><strong>Interactive Elements</strong>: Creating interactive components within the pages that can be manipulated by the user.</li>
        <li><strong>More Advanced Shaders</strong>: Designing more complex and visually stunning animated backgrounds.</li>
    </ul>
  </section>
  <section id="music" class="page">
    <h2>Music</h2>
    <p>...</p>
  </section>
  <section id="shows" class="page">
    <h2>Upcoming Shows</h2>
    <p>...</p>
  </section>
  <section id="links" class="page">
    <h2>Links</h2>
    <p>...</p>
  </section>
</main>

<script>
    // --- WebGL and Shader Logic ---
    let camera, scene, renderer, material, plane;
    let uniforms;
    const textureLoader = new THREE.TextureLoader(); // Moved to a global scope
    let mainTexture, teaserTexture;

    const canvas = document.getElementById('background-shader');

    // Use contentFetchId for secure image loading
    const mainImageId = "uploaded:album_spotify_soundcloud_bandcamp.jpg-17044220-c838-4750-9122-8d1c103f1616";
    const teaserImageId = "uploaded:single_spotify_soundcloud_bandcamp.jpg-d37ac9a6-caa1-4c00-9e2b-10356cc407a6";

    function loadTextures() {
        return new Promise((resolve, reject) => {
            let texturesLoaded = 0;
            const checkDone = () => {
                texturesLoaded++;
                if (texturesLoaded === 2) {
                    resolve();
                }
            };
            
            // The file content is loaded via contentFetchId
            const mainImageSrc = `https://generativelanguage.googleapis.com/v1beta/files/${mainImageId}?alt=media`;
            const teaserImageSrc = `https://generativelanguage.googleapis.com/v1beta/files/${teaserImageId}?alt=media`;

            mainTexture = textureLoader.load(mainImageSrc, checkDone, undefined, (err) => {
                console.error("Error loading main texture:", err);
                reject(err);
            });
            teaserTexture = textureLoader.load(teaserImageSrc, checkDone, undefined, (err) => {
                console.error("Error loading teaser texture:", err);
                reject(err);
            });
            
            // Set texture wrap and filter modes
            mainTexture.wrapS = THREE.ClampToEdgeWrapping;
            mainTexture.wrapT = THREE.ClampToEdgeWrapping;
            mainTexture.minFilter = THREE.LinearFilter;
            mainTexture.magFilter = THREE.LinearFilter;
            
            teaserTexture.wrapS = THREE.ClampToEdgeWrapping;
            teaserTexture.wrapT = THREE.ClampToEdgeWrapping;
            teaserTexture.minFilter = THREE.LinearFilter;
            teaserTexture.magFilter = THREE.NearestFilter; // Nearest filter for pixelation
        });
    }

    function init() {
        // Scene setup
        camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        scene = new THREE.Scene();
        renderer = new THREE.WebGLRenderer({ canvas: canvas });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);

        // Shader uniforms
        uniforms = {
            u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
            u_scroll: { value: 0.0 },
            u_time: { value: 0.0 },
            u_texture: { value: null }, // Main image (album)
            u_teaser_texture: { value: null }, // Teaser image (single)
        };

        // Create a plane to render our shader on
        const geometry = new THREE.PlaneGeometry(2, 2);
        material = new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader: `
                void main() {
                    gl_Position = vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                // These are the values passed from JavaScript
                uniform vec2 u_resolution;
                uniform float u_scroll;
                uniform float u_time;
                uniform sampler2D u_texture;
                uniform sampler2D u_teaser_texture;

                void main() {
                    vec2 uv = gl_FragCoord.xy / u_resolution.xy;
                    
                    float pixelationFactor = 0.0;
                    float finalRevealFactor = 0.0;

                    // First transition: pixelation of the teaser image
                    // The pixelation effect is from scroll 0.0 to 0.75
                    if (u_scroll <= 0.75) {
                        pixelationFactor = u_scroll / 0.75;
                    } else {
                        pixelationFactor = 1.0;
                        // Second transition: revealing the main image
                        // The reveal effect is from scroll 0.75 to 1.0
                        finalRevealFactor = (u_scroll - 0.75) / 0.25;
                    }

                    // Calculate the size of the pixel grid based on the pixelation factor.
                    // The mix() function makes the pixel size increase as the factor increases.
                    float pixelSize = mix(1.0, 50.0, pixelationFactor);
                    
                    // Create the pixelated UV coordinates by snapping to the grid
                    vec2 pixelatedUv = floor(uv * pixelSize) / pixelSize;
                    
                    // Sample the teaser texture using the pixelated UV coordinates
                    vec4 pixelatedTeaser = texture2D(u_teaser_texture, pixelatedUv);
                    
                    // Sample the final main texture
                    vec4 mainImage = texture2D(u_texture, uv);

                    // Smoothly blend from the pixelated teaser image to the main image
                    vec4 finalColor = mix(pixelatedTeaser, mainImage, finalRevealFactor);

                    gl_FragColor = finalColor;
                }
            `
        });
        
        // Add the plane to the scene
        plane = new THREE.Mesh(geometry, material);
        scene.add(plane);
        
        // Initial texture load using the provided image URLs
        loadTextures().then(() => {
            uniforms.u_texture.value = mainTexture;
            uniforms.u_teaser_texture.value = teaserTexture;
            animate(0); // Start animation loop after textures are loaded
        }).catch(err => console.error("Error loading textures:", err));
        
        window.addEventListener('resize', onWindowResize, false);
        window.addEventListener('scroll', onScroll, false);
    }

    function onWindowResize() {
        // Update uniforms on window resize to maintain aspect ratio
        uniforms.u_resolution.value.x = window.innerWidth;
        uniforms.u_resolution.value.y = window.innerHeight;
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onScroll() {
        // Calculate normalized scroll position
        const docHeight = document.body.scrollHeight - window.innerHeight;
        const scrollPosition = docHeight > 0 ? window.scrollY / docHeight : 0;
        
        // Update the scroll uniform
        uniforms.u_scroll.value = scrollPosition;

        // --- Menu Highlighting Logic ---
        const sections = document.querySelectorAll('.page');
        const menuLinks = document.querySelectorAll('.menu-link');
        let activeLink = 0;

        for (let i = sections.length - 1; i >= 0; i--) {
            const section = sections[i];
            // Check if the section is in the viewport
            if (window.scrollY >= section.offsetTop - 100) {
                activeLink = i;
                break;
            }
        }

        menuLinks.forEach((link, index) => {
            if (index === activeLink) {
                link.classList.add('active');
            } else {
                link.classList.remove('active');
            }
        });
    }

    function animate(time) {
        requestAnimationFrame(animate);
        uniforms.u_time.value = time * 0.001; // Update time uniform
        renderer.render(scene, camera);
    }

    init();
</script>

</body>
</html>
